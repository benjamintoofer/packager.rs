use crate::error::{CustomError, construct_error, error_code::{MajorCode, TransportStreamMinorCode}};
use crate::util::bit_reader::BitReader;

#[derive(Debug, PartialEq, Eq)]
pub struct ADTSHeader {
  id_version: u8,
  profile: u8,
  sampling_frequency_index: u8,
  channel_configuration: u8,
  frame_length: u16,
  crc: Option<u16>
}

#[derive(Debug)]
pub struct ADTSFrame {
  header: ADTSHeader,
  data: Vec<u8>,
}


#[derive(Debug)]
pub struct ADTS {
  id_version: u8,
  profile: u8,
  sampling_frequency_index: u8,
  channel_configuration: u8,
  crc: Option<u16>
}

impl ADTS {
  pub fn parse(data: &[u8]) -> Result<Vec<ADTSFrame>, CustomError> {
    let data_read = data;
    let mut index = 0usize;
    let mut adts_frames: Vec<ADTSFrame> = vec![];
    while index < data_read.len() {
      let adts_header = ADTS::parse_adts_header(data_read[index..].as_ref())?;
      let mut offset = 7usize;
      if adts_header.crc.is_some() {
        offset = 9;
      }
      let start = index + offset;
      let end = index + adts_header.frame_length as usize;
      let frame_data = data_read[start..end].to_vec();
      let adts_frame = ADTSFrame{
        header: adts_header,
        data: frame_data,
      };

      adts_frames.push(adts_frame);
      index = end;
    }
    Ok(
      adts_frames
    )
  }

  fn parse_adts_header(data: &[u8]) -> Result<ADTSHeader, CustomError> {
    let mut bit_reader = BitReader::create_bit_reader(data);
    let starting_marker = bit_reader.read_bits(16)?;

    let has_start_marker = (starting_marker & 0xFFF0) == 0xFFF0;
    if !has_start_marker {
      return Err(
        construct_error(
          MajorCode::TRANSPORT_STREAM,
          Box::new(TransportStreamMinorCode::PARSE_TS_ERROR),
          format!("Could not parse adts starting marker"),
          file!(),
          line!()
        )
      );
    }
    let temp = starting_marker & 0xF;
    let id_version = (temp & 0x8) as u8;
    let protection_absent = temp & 0x1 == 0;
    let profile = bit_reader.read_bits(2)? as u8;
    let sampling_frequency_index = bit_reader.read_bits(4)? as u8;
    // Skip private bit
    bit_reader.read_bits(1)?;
    let channel_configuration = bit_reader.read_bits(3)? as u8;
    // Skip original_copy, home, copyright_identification_bit, and copyright_identification_start
    bit_reader.read_bits(4)?;
    let frame_length = bit_reader.read_bits(13)? as u16;
    let buffer_fullness = bit_reader.read_bits(11)?;
    let number_of_raw_data_blocks_in_frame = bit_reader.read_bits(2)?;

    // Checkout ISO/IEC 13818-7: 6.2 Audio Data Transport Stream, ADTS :: Table 5 â€” Syntax of adts_frame()
    // If there are more than 1 frame per data block, we need to handle it. I think todays expectation is to
    // only have 1 aac frame per adts frame
    if number_of_raw_data_blocks_in_frame > 0 {
      return Err(
        construct_error(
          MajorCode::TRANSPORT_STREAM,
          Box::new(TransportStreamMinorCode::UNSUPPORTED_ADTS_PARSING),
          format!("Could not parse because there is more than 1 aac frame in adtc frame. This is not supported in the current implementation."),
          file!(),
          line!()
        )
      );
    }
    let mut crc: Option<u16> = None;
    if protection_absent {
      crc = Some(bit_reader.read_bits(16)? as u16);
    }

    Ok(
      ADTSHeader{
        id_version,
        profile,
        sampling_frequency_index,
        channel_configuration,
        frame_length,
        crc,
      }
    )
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use crate::error::error_code::MajorCode;

  #[test]
  fn test_parse_adts() {
    let adts_sequence: [u8; 408] = [
      // adts header
      0xFF, 0xF1, 0x50, 0x80, 0x33, 0x1F, 0xFC,
      // adts frame
      0x21, 0x0A, 0xC8, 0x7A, 0xDF, 0xF7, 0x57, 0x0E, 0x8F, 0xA0, 0xD8, 0x58, 0x28, 0x16, 0x0C, 0x05,
      0xC2, 0x81, 0x61, 0x40, 0x5C, 0x28, 0x16, 0x0A, 0x08, 0xC2, 0x86, 0x51, 0x20, 0x48, 0x28, 0x15,
      0x0A, 0x09, 0x42, 0x2B, 0x7F, 0x7F, 0x6C, 0x8D, 0xFD, 0xE7, 0xAB, 0x49, 0x72, 0x56, 0xB9, 0xA9,
      0xB9, 0x23, 0x25, 0x6B, 0x3A, 0x2A, 0x35, 0x69, 0xF4, 0x21, 0x3F, 0x5F, 0xC9, 0xCB, 0x5F, 0x1F,
      0x0F, 0xF9, 0x98, 0x78, 0x56, 0x78, 0xBE, 0x4B, 0xF8, 0x16, 0xF3, 0xD1, 0x00, 0x00, 0xF5, 0x7F,
      0x17, 0x9E, 0xDC, 0x93, 0xEE, 0x91, 0x03, 0xBF, 0xED, 0x3C, 0x57, 0xA4, 0xDF, 0x23, 0xFE, 0x0E,
      0xD5, 0x5F, 0x90, 0xE9, 0x0A, 0x6F, 0x3C, 0xF3, 0x3E, 0x75, 0xA6, 0xF6, 0x93, 0xBC, 0x72, 0xCF,
      0x3F, 0x62, 0xE5, 0x9C, 0x6D, 0xFE, 0x46, 0xC3, 0x6F, 0x77, 0x86, 0x7B, 0xDE, 0x93, 0x31, 0x98,
      0x72, 0x79, 0x12, 0x9F, 0x72, 0xFC, 0xCF, 0xFD, 0x3C, 0xD3, 0xF1, 0x8D, 0x0D, 0xBE, 0xEF, 0x3B,
      0x3B, 0xD8, 0x19, 0x78, 0x5C, 0x48, 0xCC, 0xDE, 0x2F, 0x2E, 0x30, 0x83, 0x78, 0x7B, 0xD5, 0xFF,
      0xEC, 0xA3, 0xC8, 0x5A, 0xA9, 0x9C, 0xD9, 0x3C, 0xAF, 0x2D, 0x6A, 0xBB, 0xC4, 0x88, 0xA0, 0x7E,
      0x85, 0x22, 0x29, 0x3A, 0x08, 0x30, 0x42, 0x64, 0x3F, 0x0A, 0x48, 0x7F, 0x2A, 0x05, 0x02, 0x8D,
      0xD1, 0x9C, 0x01, 0x62, 0x0A, 0x80, 0x91, 0x2A, 0x58, 0x0E, 0x74, 0x02, 0x66, 0x83, 0x01, 0xA0,
      0xC0, 0xDC, 0x28, 0x16, 0x1B, 0x85, 0x02, 0xC2, 0x42, 0x31, 0x10, 0xAA, 0x14, 0x11, 0x84, 0x44,
      0x61, 0x14, 0x3C, 0x5C, 0x5C, 0xF3, 0xDC, 0xE3, 0x7A, 0xE3, 0xDF, 0x8E, 0xBC, 0x4C, 0x99, 0x25,
      0x2D, 0x52, 0xAF, 0x45, 0xAE, 0xD5, 0x7A, 0x03, 0xF4, 0x8F, 0xBF, 0xF5, 0x75, 0xF5, 0x71, 0xF3,
      0x95, 0xEA, 0x5E, 0xD5, 0xFD, 0xF3, 0xE6, 0xD1, 0xD9, 0x77, 0x05, 0xC5, 0xFD, 0x1E, 0xFF, 0x4C,
      0xF0, 0x7E, 0xD5, 0x2D, 0x76, 0x6E, 0xF9, 0x93, 0x26, 0xD1, 0xB1, 0x7B, 0x75, 0x07, 0x14, 0x39,
      0xF0, 0xAD, 0x46, 0x17, 0xB9, 0xCF, 0x4F, 0xE1, 0x1D, 0x4F, 0x80, 0xC4, 0xC1, 0xCB, 0xD9, 0xBA,
      0x5B, 0x88, 0x86, 0x9A, 0x43, 0x60, 0x09, 0x3D, 0xBD, 0x88, 0xE0, 0xEF, 0x8E, 0x9C, 0xD7, 0x51,
      0x49, 0xC7, 0x39, 0x47, 0xFC, 0xC6, 0x78, 0xB4, 0x77, 0xD1, 0x72, 0x63, 0x14, 0xFC, 0x7B, 0xF5,
      0x58, 0xA7, 0x4D, 0x9E, 0x6D, 0x9B, 0xAB, 0x7A, 0x95, 0x5F, 0x96, 0xEE, 0x54, 0x7F, 0x2D, 0xEE,
      0x3C, 0xD5, 0x6F, 0x5D, 0xBE, 0x95, 0x29, 0x85, 0x66, 0xDE, 0x4D, 0x6E, 0x1D, 0xAC, 0x1E, 0xE8,
      0xC3, 0x42, 0x77, 0xEF, 0x0E, 0x40, 0xFB, 0x73, 0xEE, 0x21, 0x0B, 0xE9, 0x16, 0x46, 0xA4, 0x09,
      0x68, 0x14, 0xB6, 0xD1, 0x61, 0x60, 0xB2, 0x04, 0x55, 0x16, 0x08, 0xCE, 0xE5, 0xC4, 0x54, 0xD2,
      0x07
    ];
    let expected_header = ADTSHeader {
        id_version: 0,
        profile: 1,
        sampling_frequency_index: 4,
        channel_configuration: 2,
        frame_length: 408,
        crc: None,
    };

    let adts_frames = ADTS::parse(&adts_sequence).unwrap();
    assert_eq!(adts_frames[0].header, expected_header);
    assert_eq!(adts_frames[0].data.len(), 401);
  }

  #[test]
  fn test_parse_adts_error_when_multiple_aac_frames_per_adts_frame() {
    let adts_sequence: [u8; 7] = [
      // adts header
      0xFF, 0xF1, 0x50, 0x80, 0x33, 0x1F, 0xFD,
    ];

    let adts_frames_error  = ADTS::parse(&adts_sequence).unwrap_err();
    assert_eq!(adts_frames_error.major, MajorCode::TRANSPORT_STREAM);
    assert_eq!(adts_frames_error.minor, 1);
  }

  #[test]
  fn test_parse_adts_error_incorrect_start_marker() {
    let adts_sequence: [u8; 7] = [
      // adts header
      0xFF, 0x51, 0x50, 0x80, 0x33, 0x1F, 0xFD,
    ];

    let adts_frames_error  = ADTS::parse(&adts_sequence).unwrap_err();
    assert_eq!(adts_frames_error.major, MajorCode::TRANSPORT_STREAM);
    assert_eq!(adts_frames_error.minor, 0);
  }
}